#!/usr/bin/env ts-node
/**
 * Site Generator CLI Script
 * è¨˜äº‹ã‹ã‚‰GitHub Pagesã«ãƒ‡ãƒ—ãƒ­ã‚¤å¯èƒ½ãªã‚µã‚¤ãƒˆã‚’ç”Ÿæˆ
 */

import fs from 'fs/promises';
import path from 'path';
import { Logger } from '../utils/Logger';

const logger = Logger.getInstance();

interface SiteConfig {
    articlesDir: string;
    outputDir: string;
    siteTitle: string;
}

const DEFAULT_CONFIG: SiteConfig = {
    articlesDir: path.join(process.cwd(), 'articles'),
    outputDir: path.join(process.cwd(), '_site'),
    siteTitle: 'Amazon Product Articles',
};

/**
 * Markdownãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’å–å¾—
 */
async function getMarkdownFiles(dir: string): Promise<string[]> {
    try {
        const files = await fs.readdir(dir);
        return files.filter(f => f.endsWith('.md') && f !== 'README.md');
    } catch {
        return [];
    }
}

/**
 * HTMLãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ç”Ÿæˆ
 */
function generateHtmlHead(title: string): string {
    return `<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
      line-height: 1.8;
      color: #333;
      background: #fafafa;
    }
    h1 { color: #232f3e; border-bottom: 3px solid #ff9900; padding-bottom: 0.5rem; }
    h2 { color: #232f3e; margin-top: 2rem; }
    h3 { color: #37475a; }
    a { color: #0066c0; text-decoration: none; }
    a:hover { text-decoration: underline; color: #c45500; }
    .article-list { list-style: none; padding: 0; }
    .article-item {
      margin: 1rem 0;
      padding: 1.5rem;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .article-item:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    .article-item a { font-size: 1.2rem; font-weight: 600; }
    .article-content { 
      background: #fff; 
      padding: 2rem; 
      border-radius: 8px; 
      box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
    }
    .back-link { margin-bottom: 1rem; display: inline-block; }
    footer { margin-top: 3rem; padding-top: 1rem; border-top: 1px solid #ddd; color: #666; font-size: 0.9rem; }
    pre { background: #f4f4f4; padding: 1rem; border-radius: 4px; overflow-x: auto; }
    code { background: #f4f4f4; padding: 0.2rem 0.4rem; border-radius: 3px; }
    ul, ol { padding-left: 1.5rem; }
    li { margin: 0.5rem 0; }
    blockquote { border-left: 4px solid #ff9900; margin: 1rem 0; padding-left: 1rem; color: #555; }
  </style>
</head>
<body>
`;
}

/**
 * HTMLãƒ•ãƒƒã‚¿ãƒ¼ã‚’ç”Ÿæˆ
 */
function generateHtmlFooter(): string {
    const now = new Date().toISOString();
    return `
  <footer>
    <p>Generated by Amazon Product Research System | Last updated: ${now}</p>
  </footer>
</body>
</html>`;
}

/**
 * ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¸ã‚’ç”Ÿæˆ
 */
function generateIndexPage(articles: string[], config: SiteConfig): string {
    let html = generateHtmlHead(config.siteTitle);

    html += `  <h1>ğŸ“¦ ${config.siteTitle}</h1>
  <p>è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸè£½å“ãƒ¬ãƒ“ãƒ¥ãƒ¼è¨˜äº‹ä¸€è¦§</p>
  <ul class="article-list">
`;

    for (const article of articles) {
        const name = article.replace('.md', '');
        const htmlFile = `${name}.html`;
        html += `    <li class="article-item"><a href="${htmlFile}">ğŸ“„ ${name}</a></li>\n`;
    }

    html += `  </ul>`;
    html += generateHtmlFooter();

    return html;
}

/**
 * ç°¡æ˜“Markdownã‚’HTMLã«å¤‰æ›
 */
function markdownToHtml(markdown: string): string {
    let html = markdown
        // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        // è¦‹å‡ºã—
        .replace(/^### (.+)$/gm, '<h3>$1</h3>')
        .replace(/^## (.+)$/gm, '<h2>$1</h2>')
        .replace(/^# (.+)$/gm, '<h1>$1</h1>')
        // å¤ªå­—ãƒ»æ–œä½“
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.+?)\*/g, '<em>$1</em>')
        // ãƒªãƒ³ã‚¯
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>')
        // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯
        .replace(/```[\s\S]*?```/g, (match) => {
            const code = match.slice(3, -3).replace(/^\w+\n/, '');
            return `<pre><code>${code}</code></pre>`;
        })
        // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚³ãƒ¼ãƒ‰
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        // å¼•ç”¨
        .replace(/^> (.+)$/gm, '<blockquote>$1</blockquote>')
        // æ°´å¹³ç·š
        .replace(/^---$/gm, '<hr>')
        // ãƒªã‚¹ãƒˆ
        .replace(/^- (.+)$/gm, '<li>$1</li>')
        .replace(/^(\d+)\. (.+)$/gm, '<li>$2</li>');

    // é€£ç¶šã™ã‚‹<li>ã‚’ul/olã§å›²ã‚€
    html = html.replace(/(<li>.*<\/li>\n?)+/g, (match) => `<ul>${match}</ul>`);

    // é€£ç¶šã™ã‚‹<blockquote>ã‚’ãƒãƒ¼ã‚¸
    html = html.replace(/(<blockquote>.*<\/blockquote>\n?)+/g, (match) => {
        const content = match.replace(/<\/?blockquote>/g, '').trim();
        return `<blockquote>${content}</blockquote>`;
    });

    // æ®µè½
    html = html
        .split('\n\n')
        .map(block => {
            block = block.trim();
            if (!block) return '';
            if (block.startsWith('<h') || block.startsWith('<ul') || block.startsWith('<ol') ||
                block.startsWith('<pre') || block.startsWith('<blockquote') || block.startsWith('<hr')) {
                return block;
            }
            return `<p>${block.replace(/\n/g, '<br>')}</p>`;
        })
        .join('\n');

    return html;
}

/**
 * è¨˜äº‹ãƒšãƒ¼ã‚¸ã‚’ç”Ÿæˆ
 */
async function generateArticlePage(
    articlePath: string,
    config: SiteConfig
): Promise<string> {
    const content = await fs.readFile(articlePath, 'utf-8');
    const filename = path.basename(articlePath, '.md');

    let html = generateHtmlHead(`${filename} | ${config.siteTitle}`);

    html += `  <a href="index.html" class="back-link">â† è¨˜äº‹ä¸€è¦§ã«æˆ»ã‚‹</a>
  <article class="article-content">
${markdownToHtml(content)}
  </article>`;

    html += generateHtmlFooter();

    return html;
}

/**
 * ã‚µã‚¤ãƒˆã‚’ç”Ÿæˆ
 */
async function generateSite(config: SiteConfig): Promise<void> {
    logger.info('Starting site generation...');

    // å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
    await fs.mkdir(config.outputDir, { recursive: true });

    // Markdownãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’å–å¾—
    const articles = await getMarkdownFiles(config.articlesDir);

    if (articles.length === 0) {
        logger.warn('No articles found to generate site');
        // ç©ºã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¸ã‚’ä½œæˆ
        const emptyIndex = generateIndexPage([], config);
        await fs.writeFile(path.join(config.outputDir, 'index.html'), emptyIndex);
        return;
    }

    logger.info(`Found ${articles.length} articles`);

    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¸ã‚’ç”Ÿæˆ
    const indexHtml = generateIndexPage(articles, config);
    await fs.writeFile(path.join(config.outputDir, 'index.html'), indexHtml);
    logger.info('Generated index.html');

    // å„è¨˜äº‹ãƒšãƒ¼ã‚¸ã‚’ç”Ÿæˆ
    for (const article of articles) {
        const articlePath = path.join(config.articlesDir, article);
        const articleHtml = await generateArticlePage(articlePath, config);
        const outputPath = path.join(config.outputDir, article.replace('.md', '.html'));
        await fs.writeFile(outputPath, articleHtml);
        logger.info(`Generated ${article.replace('.md', '.html')}`);
    }

    logger.info(`Site generation completed: ${articles.length + 1} files`);
}

async function main(): Promise<void> {
    try {
        await generateSite(DEFAULT_CONFIG);
        process.exit(0);
    } catch (error) {
        logger.error('Site generation failed:', error);
        process.exit(1);
    }
}

main().catch((error) => {
    console.error('Unhandled error:', error);
    process.exit(1);
});
